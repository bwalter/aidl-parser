grammar<'err>(
    lookup: &line_col::LineColLookup<'input>,
    diagnostics: &'err mut Vec<Diagnostic>
);

use crate::ast;
use crate::diagnostic::{Diagnostic, DiagnosticKind};
use crate::javadoc;

pub OptAidl: Option<ast::Aidl> = {
    <p:Package> <vi:Import*> DeclaredParcelable* <oi:OptItem> => {
        oi.map(|item| ast::Aidl {
            package: p,
            imports: vi,
            item,
        })
    }
}

// e.g. package x.y.z;
pub(crate) Package: ast::Package = {
    <fp1:@L> PACKAGE <sp1:@L> <name:QualifiedName> <sp2:@R> <fp2:@R> ";" => {
        ast::Package {
            name,
            symbol_range: ast::Range::new(lookup, sp1, sp2),
            full_range: ast::Range::new(lookup, fp1, fp2),
        }
    }
}

// e.g. import x.y.z;
pub(crate) Import: ast::Import = {
    <fp1:@L> IMPORT <sp1:@L> <v:(<IDENT> ".")+> <n:IDENT> <sp2:@R> <fp2:@R> ";" => {
        ast::Import {
            path: v.join("."),
            name: n.to_owned(),
            symbol_range: ast::Range::new(lookup, sp1, sp2),
            full_range: ast::Range::new(lookup, fp1, fp2),
        }
    }
}

// e.g. x OR x.y.z
QualifiedName: String = {
    <v:(<IDENT> ".")*> <n:IDENT> => {
        if v.is_empty() {
            n.to_owned()
        } else {
            format!("{}.{}", v.join("."), n)
        }
    }
}

// e.g. parcelable MyParcelable;
pub(crate) DeclaredParcelable: () = {
    <annotations:AnnotationList>
    <p1:@L> PARCELABLE <n:QualifiedName> ";" <p2:@R> => {
        diagnostics.push(Diagnostic {
            kind: DiagnosticKind::Warning,
            range: ast::Range::new(&lookup, p1, p2),
            message: format!("Usage of declared parcelable {}", n),
            context_message: Some(String::from("declared parcelable")),
            hint: Some(String::from("It is recommended to defined parcelables in AIDL to garantee compatilibity between languages")),
            related_infos: Vec::new(),
        });
    }
}

// Interface, parcelable or enum
OptItem: Option<ast::Item> = {
    <i:Interface> => Some(ast::Item::Interface(i)),
    <p:Parcelable> => Some(ast::Item::Parcelable(p)),
    <e:Enum> => Some(ast::Item::Enum(e)),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid item", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. interface Xyz { ... }
pub(crate) Interface: ast::Interface = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> <oneway:ONEWAY?> INTERFACE <sp1:@L> <s:IDENT> <sp2:@R> "{" <v:OptInterfaceElement*> "}" <fp2:@R> => {
        // Convert Vec<Option<InterfaceElement>> into Vec<InterfaceElement>
        let elements: Vec<ast::InterfaceElement> = v.into_iter().flatten().collect();

        ast::Interface {
            oneway: oneway.is_some(),
            name: s.into(),
            elements,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// Method or const (with error recovery)
OptInterfaceElement: Option<ast::InterfaceElement> = {
    <m:Method> => Some(ast::InterfaceElement::Method(m)),
    <c:Const> => Some(ast::InterfaceElement::Const(c)),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid interface element", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. parcelable Xyz { ... }
pub(crate) Parcelable: ast::Parcelable = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> PARCELABLE <sp1:@L> <s:IDENT> <sp2:@R> "{" <v:OptParcelableMember*> "}" <fp2:@R> => {
        // Convert Vec<Option<Member>> into Vec<Member>
        let members: Vec<ast::Member> = v.into_iter().flatten().collect();

        ast::Parcelable {
            name: s.into(),
            members,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// Parcelable member
OptParcelableMember: Option<ast::Member> = {
    <m:Member> => Some(m),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid member", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. enum Xyz { ... }
pub(crate) Enum: ast::Enum = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> ENUM <sp1:@L> <s:IDENT> <sp2:@R> "{" <v:CommaSeparated<OptEnumElement>> "}" <fp2:@R> => {
        // Convert Vec<Option<EnumElement>> into Vec<EnumElement>
        let elements: Vec<ast::EnumElement> = v.into_iter().flatten().collect();

        ast::Enum {
            name: s.into(),
            elements,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// Enum element (with error recovery)
OptEnumElement: Option<ast::EnumElement> = {
    <el:EnumElement> => Some(el),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid enum element", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. @Annotation String myMethod(...) = 2;
pub(crate) Method: ast::Method = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> <owp1:@L> <oneway:ONEWAY?> <owp2:@R> <rt:Type>
    <sp1:@L> <n:IDENT> <sp2:@R>
    "(" <args:CommaSeparated<Arg>> ")"
    <vp1:@L> <v:("=" <INTEGER>)?> <vp2:@R>  // TODO: only [0-9]+
    <fp2:@R> ";" => {
        ast::Method {
            oneway: oneway.is_some(),
            name: n.to_owned(),
            return_type: rt,
            args,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            value: match v.map(str::parse) {
                Some(Ok(v)) => Some(v),
                Some(Err(e)) => {
                    diagnostics.push(Diagnostic {
                        kind: DiagnosticKind::Error,
                        range: ast::Range::new(&lookup, vp1 + 2, vp2),
                        message: format!("Invalid method value: {}", e),
                        context_message: None,
                        hint: None,
                        related_infos: Vec::new(),
                    });
                    None
                },
                None => None,
            },
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
            value_range: ast::Range::new(&lookup, vp1, vp2),
            oneway_range: ast::Range::new(&lookup, owp1, owp2),
        }
    }
}

// e.g. @Annotation inout MyType argName
pub(crate) Arg: ast::Arg = {
    <p0:@L>
    <d:Direction> 
    <annotations:AnnotationList>
    <t:Type> <sp1:@L> <n:IDENT?> <p2:@R> => {
        ast::Arg {
            direction: d,
            name: n.map(str::to_owned),
            arg_type: t,
            symbol_range: ast::Range::new(&lookup, sp1, p2),
            full_range: ast::Range::new(&lookup, p0, p2),
            annotations,
            doc: javadoc::get_javadoc(input, p0),
        }
    }
}

// Arg direction (in, out or inout)
Direction: ast::Direction = {
    <p1:@L> <d:DIRECTION?> <p2:@R> => {
        match d {
            Some("in") => ast::Direction::In(ast::Range::new(&lookup, p1, p2)),
            Some("out") => ast::Direction::Out(ast::Range::new(&lookup, p1, p2)),
            Some("inout") => ast::Direction::InOut(ast::Range::new(&lookup, p1, p2)),
            None => ast::Direction::Unspecified,
            _ => unreachable!(),
        }
    }
}

// e.g. @Annotation const int XYZ = 3;
pub(crate) Const: ast::Const = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> CONST <t:Type>
    <sp1:@L> <n:IDENT> <sp2:@R>
    "=" <v:Value>
    <fp2:@R> ";" => {
        ast::Const {
            name: n.to_owned(),
            const_type: t,
            value: v.to_owned(),
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    },
}

// e.g. @Annotation String myMember;
pub(crate) Member: ast::Member = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> <t:Type>
    <sp1:@L> <n:IDENT> <sp2:@R>
    <v:("=" <Value>)?>
    <fp2:@R> ";" => {
        ast::Member {
            name: n.to_owned(),
            member_type: t,
            value: v.map(str::to_owned),
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// e.g. @Annotation ELEMENT = 3
EnumElement: ast::EnumElement = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L>
    <sp1:@L> <n:IDENT> <sp2:@R>
    <v:("=" <Value>)?>
    <fp2:@R> => {
        ast::EnumElement {
            name: n.to_owned(),
            value: v.map(str::to_owned),
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

pub(crate) Type: ast::Type = {
    TypeVoid,
    TypePrimitive,
    TypeString,
    TypeArray,
    TypeList,
    TypeMap,
    TypeCustom,
}

TypeVoid: ast::Type = {
    <p1:@L> <n:VOID> <p2:@R> =>
        ast::Type::simple_type(n, ast::TypeKind::Void, lookup, p1, p2)
}

TypePrimitive: ast::Type = {
    <p1:@L> <n:PRIMITIVE> <p2:@R> =>
        ast::Type::simple_type(n, ast::TypeKind::Primitive, lookup, p1, p2)
}

TypeString: ast::Type = {
    <p1:@L> <n:STRING> <p2:@R> =>
        ast::Type::simple_type(n, ast::TypeKind::String, lookup, p1, p2)
}

TypeArray: ast::Type = {
    <p1:@L> <p:Type> "[" "]" <p2:@L> => {
        ast::Type::array(p, &lookup, p1, p2)
    },
}

TypeList: ast::Type = {
    <p1:@L> LIST "<" <p:Type> ">" <p2:@R> => {
        ast::Type::list(p, &lookup, p1, p2)
    },
    <p1:@L> LIST <p2:@R> => {
        ast::Type::non_generic_list(&lookup, p1, p2)
    },
}

TypeMap: ast::Type = {
    <p1:@L> MAP "<"
        <k:Type> "," <v:Type>
    ">" <p2:@R> => {
        ast::Type::map(k, v, &lookup, p1, p2)
    },
    <p1:@L> MAP <p2:@R> => {
        ast::Type::non_generic_map(&lookup, p1, p2)
    },
}

// Unresolved custom type (should be an interface, a parcelable or an enum)
TypeCustom: ast::Type = {
    <p1:@L> <n:QualifiedName> <p2:@R> => {
        ast::Type {
            name: n.to_owned(),
            kind: ast::TypeKind::Custom,
            generic_types: vec![],
            definition: None,
            symbol_range: ast::Range::new(&lookup, p1, p2),
        }
    }
}

#[inline]
AnnotationList: Vec<ast::Annotation> = {
    // Convert Vec<Option<Annotation>> into Vec<Annotation>
    <v:OptAnnotation*> => v.into_iter().flatten().collect()
}

pub(crate) OptAnnotation: Option<ast::Annotation> = {
    <n:ANNOTATION> <v:("(" <CommaSeparated<AnnotationParam>> ")")?> => {
        Some(ast::Annotation {
            name: n.to_owned(),
            key_values: v.unwrap_or_default().into_iter().collect(),
        })
    },
}

AnnotationParam: (String, Option<String>) = {
    <k:IDENT> <v:("=" <Value>)?> => (k.to_owned(), v.map(str::to_owned))
}

pub(crate) Value: &'input str = {
    INTEGER,
    FLOAT,
    QUOTED_STRING,
    BOOLEAN,
    "{" "}" => "{}",
    "{" Value+ ("," <Value>)* ","? "}" => "{...}",
}

// Comma separated list with optional trailing comma
CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

// Tokens
match {
    // Whitespaces, comments, EOL
    r"\s*" => { }, // The default whitespace skipping is disabled and an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    
    "package" => PACKAGE,
    "import" => IMPORT,
    "interface" => INTERFACE,
    "parcelable" => PARCELABLE,
    "enum" => ENUM,
    "oneway" => ONEWAY,
    "const" => CONST,
    
    r"(inout|in|out)" => DIRECTION,
    "void" => VOID,
    r"(byte|short|int|long|float|double|boolean|char)" => PRIMITIVE,
    r"(String|CharSequence)" => STRING,
    "List" => LIST,
    "Map" => MAP,
    
    r#""[^"\n\r]*""# => QUOTED_STRING,
    r#"(true|false)"# => BOOLEAN,

    r"@[a-zA-Z_][a-zA-Z0-9_]*" => ANNOTATION,
    
    // Signs
    ";",  ",", "{", "}", "(", ")", "[", "]", "<", ">", "=", ".", "-",
} else {
    // Reserved keywords
    // Note: currently only for Java and C++ but Rust should be ideally covered, too
    r"(break|case|catch|char|class|continue|default|do|double|else|enum|false|float|for|goto|if|int|long|new|private|protected|public|return|short|static|switch|this|throw|true|try|void|volatile|while)" => RESERVED_KEYWORD,
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => IDENT,
} else {
    r"[0-9]+" => INTEGER,
} else {
    r"[+-]?(\d*\.)?\d+[f]?" => FLOAT,
}
